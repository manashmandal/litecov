package comment

import (
	"fmt"
	"sort"
	"strings"

	"github.com/manashmandal/litecov/internal/coverage"
)

const Marker = "<!-- litecov -->"

type Options struct {
	Title        string
	ShowFiles    string
	ChangedFiles []string
	Threshold    float64
	WorstN       int
	RepoURL      string
	SHA          string
}

func Format(report *coverage.Report, opts Options) string {
	var sb strings.Builder

	sb.WriteString(Marker)
	sb.WriteString("\n")

	sb.WriteString(formatHeader(report, opts))
	sb.WriteString(formatQuickSummary(report))
	sb.WriteString(formatCoverageDiff(report))

	filesToShow := filterFiles(report.Files, opts)
	sb.WriteString(formatImpactedFiles(filesToShow, opts))

	sb.WriteString(formatFooter())

	return sb.String()
}

func formatHeader(report *coverage.Report, opts Options) string {
	title := opts.Title
	if title == "" {
		title = "Coverage Report"
	}
	return fmt.Sprintf("## :bar_chart: %s\n\n", title)
}

func formatQuickSummary(report *coverage.Report) string {
	emoji := getStatusEmoji(report.Coverage)
	return fmt.Sprintf("> %s **Coverage: `%.2f%%`** | **Lines: `%d/%d`** | **Files: `%d`**\n\n",
		emoji, report.Coverage, report.TotalCovered, report.TotalLines, len(report.Files))
}

func formatCoverageDiff(report *coverage.Report) string {
	var sb strings.Builder

	sb.WriteString("<details>\n")
	sb.WriteString("<summary>Coverage Diff</summary>\n\n")
	sb.WriteString("```diff\n")
	sb.WriteString("@@         Coverage Summary            @@\n")
	sb.WriteString("==========================================\n")
	sb.WriteString(fmt.Sprintf("  Coverage              %.2f%%\n", report.Coverage))
	sb.WriteString(fmt.Sprintf("  Lines           %d/%d\n", report.TotalCovered, report.TotalLines))
	sb.WriteString(fmt.Sprintf("  Files                   %d\n", len(report.Files)))
	sb.WriteString("==========================================\n")
	sb.WriteString("```\n\n")
	sb.WriteString("</details>\n\n")

	return sb.String()
}

func formatImpactedFiles(files []coverage.FileCoverage, opts Options) string {
	if len(files) == 0 {
		return ""
	}

	var sb strings.Builder

	sb.WriteString("<details>\n")
	sb.WriteString(fmt.Sprintf("<summary>Impacted Files (%d)</summary>\n\n", len(files)))
	sb.WriteString("| File | Coverage | Status |\n")
	sb.WriteString("|------|----------|--------|\n")

	for _, f := range files {
		pct := f.Percentage()
		emoji := getStatusEmoji(pct)
		fileName := formatFileName(f.Path, opts)
		sb.WriteString(fmt.Sprintf("| %s | `%.2f%%` | %s |\n", fileName, pct, emoji))
	}

	sb.WriteString("\n</details>\n\n")

	return sb.String()
}

func formatFileName(path string, opts Options) string {
	if opts.RepoURL != "" && opts.SHA != "" {
		return fmt.Sprintf("[`%s`](%s/blob/%s/%s)", path, opts.RepoURL, opts.SHA, path)
	}
	return fmt.Sprintf("`%s`", path)
}

func formatFooter() string {
	return "---\n<sub>:chart_with_upwards_trend: Generated by [LiteCov](https://github.com/manashmandal/litecov)</sub>\n"
}

func getStatusEmoji(coverage float64) string {
	switch {
	case coverage >= 80:
		return ":white_check_mark:"
	case coverage >= 50:
		return ":warning:"
	default:
		return ":x:"
	}
}

func formatUncoveredLines(lines []int, repoURL, sha, filePath string) string {
	if len(lines) == 0 {
		return "-"
	}

	sort.Ints(lines)

	var ranges []string
	start := lines[0]
	end := lines[0]

	for i := 1; i < len(lines); i++ {
		if lines[i] == end+1 {
			end = lines[i]
		} else {
			ranges = append(ranges, formatRange(start, end, repoURL, sha, filePath))
			start = lines[i]
			end = lines[i]
		}
	}
	ranges = append(ranges, formatRange(start, end, repoURL, sha, filePath))

	if len(ranges) > 5 {
		return strings.Join(ranges[:5], ", ") + fmt.Sprintf(" +%d more", len(ranges)-5)
	}
	return strings.Join(ranges, ", ")
}

func formatRange(start, end int, repoURL, sha, filePath string) string {
	if repoURL != "" && sha != "" {
		if start == end {
			return fmt.Sprintf("[L%d](%s/blob/%s/%s#L%d)", start, repoURL, sha, filePath, start)
		}
		return fmt.Sprintf("[L%d-%d](%s/blob/%s/%s#L%d-L%d)", start, end, repoURL, sha, filePath, start, end)
	}
	if start == end {
		return fmt.Sprintf("L%d", start)
	}
	return fmt.Sprintf("L%d-%d", start, end)
}

func filterFiles(files []coverage.FileCoverage, opts Options) []coverage.FileCoverage {
	switch {
	case opts.ShowFiles == "all":
		return files

	case opts.ShowFiles == "changed":
		if len(opts.ChangedFiles) == 0 {
			return files
		}
		changedSet := make(map[string]bool)
		for _, f := range opts.ChangedFiles {
			changedSet[f] = true
		}
		var result []coverage.FileCoverage
		for _, f := range files {
			if changedSet[f.Path] {
				result = append(result, f)
			}
		}
		return result

	case strings.HasPrefix(opts.ShowFiles, "threshold:"):
		var result []coverage.FileCoverage
		for _, f := range files {
			if f.Percentage() < opts.Threshold {
				result = append(result, f)
			}
		}
		return result

	case strings.HasPrefix(opts.ShowFiles, "worst:"):
		sorted := make([]coverage.FileCoverage, len(files))
		copy(sorted, files)
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].Percentage() < sorted[j].Percentage()
		})
		if opts.WorstN > len(sorted) {
			return sorted
		}
		return sorted[:opts.WorstN]

	default:
		return files
	}
}

// LineRange represents a contiguous range of line numbers.
type LineRange struct {
	Start int
	End   int
}

// GroupConsecutiveLines groups consecutive line numbers into ranges.
func GroupConsecutiveLines(lines []int) []LineRange {
	if len(lines) == 0 {
		return nil
	}

	sorted := make([]int, len(lines))
	copy(sorted, lines)
	sort.Ints(sorted)

	var ranges []LineRange
	start := sorted[0]
	end := sorted[0]

	for i := 1; i < len(sorted); i++ {
		if sorted[i] == end+1 {
			end = sorted[i]
		} else {
			ranges = append(ranges, LineRange{Start: start, End: end})
			start = sorted[i]
			end = sorted[i]
		}
	}
	ranges = append(ranges, LineRange{Start: start, End: end})

	return ranges
}
