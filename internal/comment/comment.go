package comment

import (
	"fmt"
	"sort"
	"strings"

	"github.com/manashmandal/litecov/internal/coverage"
)

const Marker = "<!-- litecov -->"

type Options struct {
	Title        string
	ShowFiles    string
	ChangedFiles []string
	Threshold    float64
	WorstN       int
	RepoURL      string
	SHA          string
}

func Format(report *coverage.Report, opts Options) string {
	var sb strings.Builder

	sb.WriteString(Marker)
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("## %s\n\n", opts.Title))

	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| **Coverage** | `%.2f%%` |\n", report.Coverage))
	sb.WriteString(fmt.Sprintf("| **Lines** | `%d/%d` |\n", report.TotalCovered, report.TotalLines))
	sb.WriteString(fmt.Sprintf("| **Files** | `%d` |\n", len(report.Files)))
	sb.WriteString("\n")

	filesToShow := filterFiles(report.Files, opts)

	if len(filesToShow) > 0 {
		sb.WriteString("| File | Coverage | Uncovered Lines |\n")
		sb.WriteString("|------|----------|----------------|\n")
		for _, f := range filesToShow {
			pct := f.Percentage()
			indicator := ""
			if pct < 50 {
				indicator = " :warning:"
			}
			fileName := fmt.Sprintf("`%s`", f.Path)
			if opts.RepoURL != "" && opts.SHA != "" {
				fileName = fmt.Sprintf("[`%s`](%s/blob/%s/%s)", f.Path, opts.RepoURL, opts.SHA, f.Path)
			}
			uncovered := formatUncoveredLines(f.UncoveredLines, opts.RepoURL, opts.SHA, f.Path)
			sb.WriteString(fmt.Sprintf("| %s | `%.2f%%`%s | %s |\n", fileName, pct, indicator, uncovered))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("<sub>Generated by [LiteCov](https://github.com/manashmandal/litecov)</sub>\n")

	return sb.String()
}

func formatUncoveredLines(lines []int, repoURL, sha, filePath string) string {
	if len(lines) == 0 {
		return "-"
	}

	sort.Ints(lines)

	var ranges []string
	start := lines[0]
	end := lines[0]

	for i := 1; i < len(lines); i++ {
		if lines[i] == end+1 {
			end = lines[i]
		} else {
			ranges = append(ranges, formatRange(start, end, repoURL, sha, filePath))
			start = lines[i]
			end = lines[i]
		}
	}
	ranges = append(ranges, formatRange(start, end, repoURL, sha, filePath))

	if len(ranges) > 5 {
		return strings.Join(ranges[:5], ", ") + fmt.Sprintf(" +%d more", len(ranges)-5)
	}
	return strings.Join(ranges, ", ")
}

func formatRange(start, end int, repoURL, sha, filePath string) string {
	if repoURL != "" && sha != "" {
		if start == end {
			return fmt.Sprintf("[L%d](%s/blob/%s/%s#L%d)", start, repoURL, sha, filePath, start)
		}
		return fmt.Sprintf("[L%d-%d](%s/blob/%s/%s#L%d-L%d)", start, end, repoURL, sha, filePath, start, end)
	}
	if start == end {
		return fmt.Sprintf("L%d", start)
	}
	return fmt.Sprintf("L%d-%d", start, end)
}

func filterFiles(files []coverage.FileCoverage, opts Options) []coverage.FileCoverage {
	switch {
	case opts.ShowFiles == "all":
		return files

	case opts.ShowFiles == "changed":
		if len(opts.ChangedFiles) == 0 {
			return files
		}
		changedSet := make(map[string]bool)
		for _, f := range opts.ChangedFiles {
			changedSet[f] = true
		}
		var result []coverage.FileCoverage
		for _, f := range files {
			if changedSet[f.Path] {
				result = append(result, f)
			}
		}
		return result

	case strings.HasPrefix(opts.ShowFiles, "threshold:"):
		var result []coverage.FileCoverage
		for _, f := range files {
			if f.Percentage() < opts.Threshold {
				result = append(result, f)
			}
		}
		return result

	case strings.HasPrefix(opts.ShowFiles, "worst:"):
		sorted := make([]coverage.FileCoverage, len(files))
		copy(sorted, files)
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].Percentage() < sorted[j].Percentage()
		})
		if opts.WorstN > len(sorted) {
			return sorted
		}
		return sorted[:opts.WorstN]

	default:
		return files
	}
}
